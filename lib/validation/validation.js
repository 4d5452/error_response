const RULES = require('./rules');

module.exports = {
  "rules": RULES,
  "validate": validate
}

/**********************Functions******************************/
/*accepts a map whose key:value pairs represent the complex 
 * tree-like structure generated by the contentType get method.
 * leaf nodes are identified by their type attribute.  This recursive 
 * function treats those leaf nodes a base cases.  At the base case a results
 * array is populated and returned to the original caller.  Each iteration
 * that is not treated as a leaf prepares the next call by pulling the 
 * set of nested maps which will make up the next consecutive recursive calls*/
function validate(map, id, subject) {
  let ret = {};
  let results = [];

  let leaf = map.has('type');

  if(leaf) {
    /*test for requirment*/
    if(!map.has('required')){
      throw new Error(`'required' not found on ${id}`);
    }
    let required = map.get('required');
    if(required && !subject) {
      /*required and not found*/
      results.push(RULES['required'].err(id));
    } else if(!required && !subject) {
      /*not required and not found*/
      return undefined;
    } else {
      /*not required and found || required and found*/
      map.delete('required'); // not very good i'm sure...
      /*test remaining values*/
      map.forEach((value, key, map) => {
        if(!RULES[key]) {
          throw new Error(`Unsupported rule ${key} in ${id}`);
        }
        if(!RULES[key].validate(value, subject)) {
          results.push(RULES[key].err(id, value));
        }
      });
    }
    return results;
  }
  
  map.forEach((value, key, map) => {
    /*because the subject may not contain a complete structure that mimics
     * the pre-defined map structure, replace any missing subject values
     * with undefined so we may continue to build the response*/
    let tmp = subject ? subject[key] : undefined;
    ret[key] = validate(value, key, tmp);
  });

  return ret;
}

// returns a new object that contains error messages (if any) for each
//  key within the passed object.  Below is the format of the returned object:
//  rtnObject = {
//    key1: ['key1_errMsgMaxLength', 'key2_errMsgMinLength', etc...],
//    key2: ['key2_errMsgRequired'],
//    key3: [],
//    key4: { 
//      'sub_key1_errMsg...'
//      sub_key2: {
//        'sub_key1_errMsg...'
//      }
//    }
//    etc...
//  }

