const RULES = require('./rules');

module.exports = {
  "rules": RULES,
  "validate": validate
}

/**********************Functions******************************/
/*accepts a map whose key:value pairs represent the complex 
 * tree-like structure generated by the contentType get method.
 * leaf nodes are identified by their type attribute.  This recursive 
 * function treats those leaf nodes a base cases.  At the base case a results
 * array is populated and returned to the original caller.  Each iteration
 * that is not treated as a leaf prepares the next call by pulling the 
 * set of nested maps which will make up the next consecutive recursive calls*/
function validate(object, id, subject) {

  let leaf = object['type'] ? true : false;

  if(leaf) {
    let results = [];
    /*test for requirment*/
    if(object['required'] === null){
      throw new Error(`'required' not found on ${id}`);
    }
    let required = object['required'];
    if(required && !subject) {
      /*required and not found*/
      results.push(RULES['required'].err(id));
    } else if(!required && !subject) {
      /*not required and not found*/
      return undefined;
    } else {
      /*not required and found || required and found*/
      /*test remaining values*/
      for(let key in object) {
        if(key === 'required') { continue; } //hate checking for this everytime
        if(!RULES[key]) {
          throw new Error(`Unsupported rule ${key} in ${id}`);
        }
        if(!RULES[key].validate(object[key], subject)) {
          results.push(RULES[key].err(id, object[key]));
        }
      }
    }
    return results.length > 0 ? results : null;
  } else {
    let ret = {};
    for(let key in object) {
      /*because the subject may not contain a complete structure that mimics
       * the pre-defined map structure, replace any missing subject values
       * with undefined so we may continue to build the response*/
      let tmp = subject ? subject[key] : undefined;
      let result = validate(object[key], key, tmp);
      if(result) {
        /*If validate returns something, an error occurred.*/
        ret[key] = result;
      }
    }

    return Object.keys(ret).length > 0 ? ret : null;
  }
}

// returns a new object that contains error messages (if any) for each
//  key within the passed object.  Below is the format of the returned object:
//  rtnObject = {
//    key1: ['key1_errMsgMaxLength', 'key2_errMsgMinLength', etc...],
//    key2: ['key2_errMsgRequired'],
//    key3: [],
//    key4: { 
//      'sub_key1_errMsg...'
//      sub_key2: {
//        'sub_key1_errMsg...'
//      }
//    }
//    etc...
//  }
//
//  or "null" if no error found

